package model;

import com.sun.org.apache.regexp.internal.RE;
import domainapp.basics.model.meta.DAssoc;
import domainapp.basics.model.meta.DAttr;
import domainapp.basics.model.meta.DOpt;
import domainapp.basics.model.meta.Select;
import domainapp.basics.util.Tuple;

import java.rmi.Remote;
import java.util.List;

/**
 * Created by Hoang Phuong on 4/28/2017.
 */
public class Report {
    @DAttr(name = "reportId", type = DAttr.Type.String, id = true, auto = true, length = 10, mutable = false, optional = false)
    private String reportId;

    @DAttr(name = "averageAttack", type = DAttr.Type.Float, length = 10, mutable = false)
    private Float averageAttack;

    @DAttr(name = "heroes", type = DAttr.Type.Collection, optional = false,
            serialisable = false, filter = @Select(clazz = Hero.class))
    @DAssoc(ascName = "report-has-heroes", role = "heroes",
            ascType = DAssoc.AssocType.One2Many, endType = DAssoc.AssocEndType.One,
            associate = @DAssoc.Associate(type = Hero.class, cardMin = 0, cardMax = 25))
    private List<Hero> heroes;

    private static Integer idCounter = 0;

    public Report(String reportId, Float averageAttack, List<Hero> heroes) {
        this.reportId = Report.class.getSimpleName() + nextId(reportId);
        this.averageAttack = updateAverageAttack(heroes);
        this.heroes = heroes;
    }

    public Report(List<Hero> heroes) {
        this("", null, heroes);
        updateAverageAttack(heroes);
    }

    public Report() {
        this("", null, null);
        updateAverageAttack(null);
    }

    protected static String nextId(String id) {
        idCounter++;
        return id + idCounter;


    }

    @DOpt(type = DOpt.Type.AutoAttributeValueSynchroniser)
    public static void updateAutoGeneratedValue(
            DAttr attrib,
            Tuple derivingValue,
            Object minVal,
            Object maxVal) {
        if (minVal != null && maxVal != null) {
            if (attrib.name().equals("id")) {
                int maxIdVal = Integer.parseInt(maxVal.toString().replaceAll("[^\\d.]", ""));
                if (maxIdVal > idCounter)
                    idCounter = maxIdVal;
            }
        }
    }

    @DOpt(type = DOpt.Type.LinkAdder)
    public boolean addHero(Hero hero) {
        if (!this.heroes.contains(hero)) {
            this.heroes.add(hero);
            return true;
        }
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdderNew)
    public boolean addNewHero(Hero hero) {
        this.heroes.add(hero);
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdder)
    public boolean addHeroes(List<Hero> heroes) {
        for (Hero hero : heroes) {
            if (!this.heroes.contains(hero)) {
                this.heroes.add(hero);
                return true;
            }
        }
        return false;
    }

    @DOpt(type = DOpt.Type.LinkAdderNew)
    public boolean addNewHeroes(List<Hero> heroes) {
        this.heroes.addAll(heroes);
        return false;
    }

    @DOpt(type = DOpt.Type.LinkRemover)
    public boolean removeHero(Hero hero) {
        return this.heroes.remove(hero);
    }

    public String getReportId() {
        return reportId;
    }

    public void setReportId(String reportId) {
        this.reportId = reportId;
    }

    public List<Hero> getHeroes() {
        return heroes;
    }

    public void setHeroes(List<Hero> heroes) {
        this.heroes = heroes;
    }

    public Float getAverageAttack() {
        return averageAttack = updateAverageAttack(this.heroes);
    }

    public void setAverageAttack(Float averageAttack) {
        this.averageAttack = updateAverageAttack(this.heroes);

    }

    private float updateAverageAttack(List<Hero> heroes) {
        if (heroes != null) {
            Integer sum = 0;
            for (Hero hero : heroes) {
                sum += hero.getAttack();
            }
            return this.averageAttack = (float) (sum / heroes.size());
        } else {
            return 0;
        }
    }
}
